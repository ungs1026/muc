<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSAP.js 기능 정리 및 예제 프리뷰 (수정본)</title>
    <style>
        /* 기본 스타일 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            margin: 0;
            padding: 20px;
            padding-top: 80px; /* 고정된 네비게이션 높이만큼 패딩 추가 */
        }

        h1, h2, h3 {
            color: #2c3e50;
            padding-bottom: 10px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 2px solid #4CAF50; /* GSAP Green */
        }

        h2 {
            margin-top: 40px;
            border-bottom: 2px solid #ccc;
            font-size: 2em;
        }

        h3 {
            font-size: 1.5em;
            color: #34495e;
            border-bottom: 1px solid #e0e0e0;
            margin-top: 40px;
        }
        
        p {
            line-height: 1.6;
        }

        hr {
            border: 0;
            height: 2px;
            background: #ddd;
            margin: 80px 0;
        }

        /* 네비게이션 */
        nav {
            position: sticky;
            top: 0;
            width: 100%;
            background-color: #34495e;
            padding: 15px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            left: 0;
        }

        nav a {
            color: white;
            text-decoration: none;
            padding: 5px 15px;
            margin: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        nav a:hover {
            background-color: #4CAF50;
        }
        
        /* 컨텐츠 섹션 */
        .feature-section {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        /* 프리뷰 박스 */
        .preview-box {
            position: relative;
            background-color: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            min-height: 150px;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .box {
            width: 50px;
            height: 50px;
            background-color: #4CAF50;
            border-radius: 5px;
        }
        
        .scroll-box {
            width: 80px;
            height: 80px;
            background-color: #f39c12;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .pin-container {
            height: 300vh;
            position: relative;
        }
        .pin-content {
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        /* 컨트롤 버튼 */
        .controls {
            margin-bottom: 20px;
        }

        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            margin-right: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #2980b9;
        }
        
        .btn.gsap-btn {
             background-color: #4CAF50;
        }
        .btn.gsap-btn:hover {
             background-color: #45a049;
        }
        
        .btn.reset-btn {
            background-color: #e74c3c;
        }
        .btn.reset-btn:hover {
            background-color: #c0392b;
        }

        .btn.pause-btn {
            background-color: #f39c12;
        }
        .btn.pause-btn:hover {
            background-color: #d35400;
        }

        /* 코드 블록 */
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
        }

        code {
            display: block;
            white-space: pre;
        }

        /* === [수정/추가] 프로그레스 바 스타일 === */
        .progress-bar {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            margin: 15px 0;
            height: 8px;
            background: #ddd;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 5px;
        }
        .progress-bar:hover {
            opacity: 1;
        }
        .progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4CAF50; /* GSAP Green */
            cursor: pointer;
            border-radius: 50%;
        }
        .progress-bar::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
        }

        /* 텍스트 애니메이션 */
        .text-preview {
            font-weight: bold;
            font-size: 2.5em;
            color: #2c3e50;
        }
        
        /* 콜백 로그 */
        #callback-log {
            width: 100%;
            height: 100px;
            background-color: #2d2d2d;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            padding: 10px;
            border-radius: 4px;
            overflow-y: scroll;
            box-sizing: border-box;
            margin-top: 15px;
        }
    </style>
</head>
<body>

    <nav>
        <a href="#core-features">Core Features</a>
        <a href="#scroll-trigger">ScrollTrigger</a>
        <a href="#text-animation">Text Animation</a>
        <a href="#svg-animation">SVG Animation</a>
    </nav>

    <h1>GSAP.js 기능 정리 및 예제 프리뷰 (수정본)</h1>

    <div id="core-features">
        <h2>GSAP Core Features</h2>
        
        <div id="tweens" class="feature-section">
            <h3>Tweens (트윈)</h3>
            <p>GSAP의 가장 기본적인 기능으로, 속성의 시작 값과 끝 값 사이를 보간(interpolate)하여 애니메이션을 만듭니다. `gsap.to()`, `gsap.from()`, `gsap.fromTo()`가 있습니다.</p>
            <div class="preview-box"><div class="box tween-box"></div></div>
            <div class="controls">
                <button class="btn gsap-btn" onclick="tween.play()">Play</button>
                <button class="btn pause-btn" onclick="tween.pause()">Pause</button>
                <button class="btn reset-btn" onclick="tween.restart()">Restart</button>
            </div>
            <pre><code>const tween = gsap.to(".tween-box", { 
  x: 300, 
  rotation: 360, 
  duration: 2, 
  ease: "power2.inOut",
  paused: true 
});</code></pre>
        </div>

        <div id="timelines" class="feature-section">
            <h3>Timelines (타임라인)</h3>
            <p>여러 트윈을 하나의 시퀀스로 묶어 복잡한 애니메이션을 쉽게 제어할 수 있게 합니다. 각 애니메이션의 시작 시간, 순서를 정밀하게 조절할 수 있습니다. 아래 프로그레스 바로 진행 상태를 제어해보세요.</p>
            <div class="preview-box">
                <div class="box timeline-box" style="background-color:#FF1461"></div>
                <div class="box timeline-box" style="background-color:#14FF7A"></div>
                <div class="box timeline-box" style="background-color:#14B4FF"></div>
            </div>
            <div class="controls">
                <button class="btn gsap-btn" onclick="timeline.play()">Play</button>
                <button class="btn pause-btn" onclick="timeline.pause()">Pause</button>
                <button class="btn reset-btn" onclick="timeline.restart()">Restart</button>
            </div>
            <input type="range" id="timeline-progress" class="progress-bar" value="0" min="0" max="100" step="0.1">
            
            <pre><code>// [수정] 더 복잡한 타임라인 구성 및 프로그레스 바 연동
const timeline = gsap.timeline({ 
    paused: true, 
    repeat: -1, 
    yoyo: true,
    // onUpdate 콜백으로 타임라인 진행률에 따라 바의 값을 업데이트
    onUpdate: () => {
        timelineProgress.value = timeline.progress() * 100;
    }
});

timeline
  .to(".timeline-box:nth-child(1)", { x: -200, rotation: -360, ease: "power1.inOut", duration: 1 })
  .to(".timeline-box:nth-child(2)", { y: 100, scale: 1.5, ease: "bounce.out", duration: 1 }, "-=0.7")
  .to(".timeline-box:nth-child(3)", { x: 200, rotation: 360, ease: "power1.inOut", duration: 1 }, "<")
  .to(".timeline-box", { rotation: 0, scale: 1, ease: "elastic.out(1, 0.3)", duration: 1.5, stagger: 0.1 }, "+=0.2");

// 프로그레스 바 'input' 이벤트로 타임라인 제어
timelineProgress.addEventListener('input', () => {
  timeline.progress(timelineProgress.value / 100).pause();
});</code></pre>
        </div>
        <div id="staggering" class="feature-section">
            <h3>Staggering (스태거링)</h3>
            <p>여러 대상(targets)에 대해 순차적으로 시차를 두고 애니메이션을 적용하여 동적인 효과를 만듭니다.</p>
            <div class="preview-box">
                <div class="box stagger-box"></div><div class="box stagger-box"></div><div class="box stagger-box"></div><div class="box stagger-box"></div><div class="box stagger-box"></div>
            </div>
            <div class="controls">
                <button class="btn gsap-btn" onclick="staggerAnim.play()">Play</button>
                <button class="btn pause-btn" onclick="staggerAnim.pause()">Pause</button>
                <button class="btn reset-btn" onclick="staggerAnim.restart()">Restart</button>
            </div>
            <pre><code>const staggerAnim = gsap.to(".stagger-box", {
  y: 50,
  duration: 0.5,
  ease: "back.out(1.7)",
  stagger: 0.1, // 각 요소마다 0.1초의 딜레이
  repeat: -1,
  yoyo: true,
  paused: true
});</code></pre>
        </div>
        
        <div id="callbacks" class="feature-section">
            <h3>Callbacks (콜백)</h3>
            <p>애니메이션의 특정 이벤트(시작, 업데이트, 완료 등)가 발생했을 때 함수를 실행합니다.</p>
            <div class="preview-box" style="flex-direction: column; align-items: stretch;">
                <div class="box callbacks-box"></div>
                <div id="callback-log"></div>
            </div>
            <div class="controls">
                <button class="btn gsap-btn" onclick="callbackAnim.play()">Play</button>
                <button class="btn pause-btn" onclick="callbackAnim.pause()">Pause</button>
                <button class="btn reset-btn" onclick="resetCallback()">Restart</button>
            </div>
            <pre><code>const callbackAnim = gsap.to(".callbacks-box", {
  x: 250,
  duration: 1.5,
  repeat: 1,
  yoyo: true,
  paused: true,
  onStart: () => logCallback("Animation Started"),
  onUpdate: function() { /* logCallback(`Update: progress is ${this.progress().toFixed(2)}`); // 너무 많아 주석처리 */ },
  onRepeat: () => logCallback("Animation Repeated"),
  onComplete: () => logCallback("Animation Completed!")
});</code></pre>
        </div>
    </div>

    <hr>
    
    <div id="scroll-trigger">
        <h2>ScrollTrigger (스크롤 애니메이션)</h2>
        <p>GSAP의 강력한 플러그인으로, 스크롤 위치에 따라 애니메이션을 트리거하고 제어합니다. 스크롤과 상호작용하는 다채로운 웹 경험을 만들 수 있습니다.</p>

        <div id="scroll-scrub" class="feature-section">
            <h3>Scrub (스크럽)</h3>
            <p>스크롤바의 움직임에 애니메이션 진행 상태를 직접 연결합니다. 스크롤을 위아래로 움직이면 애니메이션이 재생/되감기 됩니다.</p>
            <div class="preview-box">
                <div class="scroll-box scrub-box">Scrub</div>
            </div>
            <pre><code>gsap.registerPlugin(ScrollTrigger);

gsap.to(".scrub-box", {
  x: 400,
  rotation: 360,
  scale: 1.5,
  scrollTrigger: {
    trigger: ".scrub-box",
    start: "top 80%", // 뷰포트 80% 지점에서 시작
    end: "bottom 20%", // 뷰포트 20% 지점에서 종료
    scrub: true, // 스크롤에 애니메이션을 연결
    markers: true // 개발용 마커 표시
  }
});</code></pre>
        </div>

        <div id="scroll-pinning" class="feature-section">
            <h3>Pinning (고정)</h3>
            <p>스크롤하는 동안 특정 요소를 뷰포트의 특정 위치에 고정(pin)시킬 수 있습니다. 스크롤이 지정된 범위를 벗어나면 고정이 해제됩니다.</p>
             <p style="font-weight:bold; color: #c0392b;">※ 아래 예제는 독립적인 스크롤 컨테이너 없이 body 스크롤을 기준으로 동작하므로, 페이지를 스크롤하여 확인해주세요.</p>
            <div class="pin-container">
                 <div class="pin-content">
                    <div class="scroll-box pin-box">PIN ME</div>
                </div>
            </div>
            <pre><code>gsap.to(".pin-box", {
  scale: 2,
  rotation: 360,
  scrollTrigger: {
    trigger: ".pin-content",
    start: "top top",
    end: "+=500", // 트리거 시작점부터 500px 스크롤될 때까지
    pin: ".pin-box", // .pin-box 요소를 고정
    scrub: 1,
    markers: true
  }
});</code></pre>
        </div>
        
         <div id="scroll-toggle" class="feature-section">
            <h3>Toggle Actions (토글 액션)</h3>
            <p>요소가 뷰포트에 들어오고 나갈 때(onEnter, onLeave)와 같은 특정 이벤트에 따라 애니메이션을 제어(play, pause, resume, reset 등)합니다.</p>
            <div class="preview-box">
                <div class="box toggle-box"></div>
            </div>
            <pre><code>gsap.to(".toggle-box", {
  x: 300,
  duration: 1.5,
  paused: true, // 초기에 멈춤
  scrollTrigger: {
    trigger: ".toggle-box",
    start: "top 70%",
    // onEnter, onLeave, onEnterBack, onLeaveBack
    toggleActions: "play pause resume reset",
    markers: true
  }
});</code></pre>
        </div>
    </div>
    
    <hr>
    
    <div id="text-animation" class="feature-section">
        <h2>Text Animation (텍스트 애니메이션)</h2>
        <p>TextPlugin을 사용하여 타이핑 효과나 숫자 카운팅과 같은 텍스트 관련 애니메이션을 쉽게 구현할 수 있습니다.</p>
        <div class="preview-box">
            <h3 class="text-preview" id="text-typing"></h3>
        </div>
        <div class="controls">
            <button class="btn gsap-btn" onclick="textAnim.play()">Play</button>
            <button class="btn pause-btn" onclick="textAnim.pause()">Pause</button>
            <button class="btn reset-btn" onclick="textAnim.restart()">Restart</button>
        </div>
        <pre><code>gsap.registerPlugin(TextPlugin);

const textAnim = gsap.to("#text-typing", {
  text: "GSAP is the best animation library!",
  duration: 4,
  ease: "none",
  paused: true
});</code></pre>
    </div>
    
    <hr>
    
    <div id="svg-animation" class="feature-section">
        <h2>SVG Motion Path (SVG 경로 애니메이션)</h2>
        <p>MotionPathPlugin을 사용하여 모든 요소를 SVG 경로(path)를 따라 움직이게 할 수 있습니다. 경로의 각도에 맞춰 자동으로 회전시킬 수도 있습니다.</p>
        <div class="preview-box">
            <svg width="250" height="150" viewBox="0 0 250 150">
                <path id="motionPath" fill="none" stroke="#ddd" stroke-width="2" d="M20,75 C 80,150 170,-20 230,75"/>
            </svg>
            <div class="box svg-box"></div>
        </div>
        <div class="controls">
            <button class="btn gsap-btn" onclick="svgAnim.play()">Play</button>
            <button class="btn pause-btn" onclick="svgAnim.pause()">Pause</button>
            <button class="btn reset-btn" onclick="svgAnim.restart()">Restart</button>
        </div>
        <pre><code>gsap.registerPlugin(MotionPathPlugin);

const svgAnim = gsap.to(".svg-box", {
  duration: 3,
  repeat: -1,
  yoyo: true,
  ease: "power1.inOut",
  paused: true,
  motionPath: {
    path: "#motionPath",
    align: "#motionPath",
    alignOrigin: [0.5, 0.5], // 박스의 중심으로 정렬
    autoRotate: true // 경로 방향에 따라 자동 회전
  }
});</code></pre>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/TextPlugin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/MotionPathPlugin.min.js"></script>
    
    <script>
        // --- GSAP 플러그인 등록 ---
        gsap.registerPlugin(ScrollTrigger, TextPlugin, MotionPathPlugin);

        // --- Core Features ---
        // 1. Tweens
        const tween = gsap.to(".tween-box", { 
            x: 300, 
            rotation: 360, 
            duration: 2, 
            ease: "power2.inOut",
            paused: true 
        });

        // 2. Timelines [수정]
        const timelineProgress = document.querySelector('#timeline-progress');
        const timeline = gsap.timeline({ 
            paused: true, 
            repeat: -1, 
            yoyo: true,
            onUpdate: () => {
                // 타임라인이 업데이트될 때마다 프로그레스 바의 값을 동기화
                timelineProgress.value = timeline.progress() * 100;
            }
        });

        // 더 세부적인 애니메이션으로 수정
        timeline
            .to(".timeline-box:nth-child(1)", { x: -200, rotation: -360, ease: "power1.inOut", duration: 1 })
            .to(".timeline-box:nth-child(2)", { y: 100, scale: 1.5, ease: "bounce.out", duration: 1 }, "-=0.7")
            .to(".timeline-box:nth-child(3)", { x: 200, rotation: 360, ease: "power1.inOut", duration: 1 }, "<")
            .to(".timeline-box", { rotation: 0, scale: 1, ease: "elastic.out(1, 0.3)", duration: 1.5, stagger: 0.1 }, "+=0.2");
        
        // 프로그레스 바를 조작했을 때 타임라인 위치를 변경하고 일시정지
        timelineProgress.addEventListener('input', () => {
            timeline.progress(timelineProgress.value / 100).pause();
        });


        // 3. Staggering
        const staggerAnim = gsap.to(".stagger-box", {
            y: 50,
            duration: 0.5,
            ease: "back.out(1.7)",
            stagger: 0.1,
            repeat: -1,
            yoyo: true,
            paused: true
        });
        
        // 4. Callbacks
        const logEl = document.querySelector('#callback-log');
        const logCallback = (message) => { 
            logEl.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${message}</div>`; 
            logEl.scrollTop = logEl.scrollHeight; 
        };
        const callbackAnim = gsap.to(".callbacks-box", {
            x: 250,
            duration: 1.5,
            repeat: 1,
            yoyo: true,
            paused: true,
            onStart: () => logCallback("Animation Started"),
            onRepeat: () => logCallback("Animation Repeated"),
            onComplete: () => logCallback("Animation Completed!")
        });
        function resetCallback() {
            logEl.innerHTML = '';
            callbackAnim.restart();
        }

        // --- ScrollTrigger ---
        // 5. Scrub
        gsap.to(".scrub-box", {
            x: 400,
            rotation: 360,
            scale: 1.5,
            scrollTrigger: {
                trigger: ".scrub-box",
                start: "top 80%",
                end: "bottom 20%",
                scrub: true,
                markers: false // true로 바꾸면 마커가 보입니다.
            }
        });
        
        // 6. Pinning
        gsap.to(".pin-box", {
          scale: 2,
          rotation: 360,
          scrollTrigger: {
            trigger: ".pin-content",
            start: "top top",
            end: "+=500",
            pin: ".pin-box",
            scrub: 1,
            markers: false
          }
        });
        
        // 7. Toggle Actions
        const toggleTween = gsap.to(".toggle-box", {
          x: 300,
          duration: 1.5,
          paused: true,
          scrollTrigger: {
            trigger: ".toggle-box",
            start: "top 70%",
            toggleActions: "play pause resume reset", // onEnter, onLeave, onEnterBack, onLeaveBack
            markers: false
          }
        });

        // --- Text Animation ---
        // 8. TextPlugin
        const textAnim = gsap.to("#text-typing", {
            text: "GSAP is the best animation library!",
            duration: 4,
            ease: "none",
            paused: true
        });

        // --- SVG Motion Path ---
        // 9. MotionPathPlugin
        const svgAnim = gsap.to(".svg-box", {
          duration: 3,
          repeat: -1,
          yoyo: true,
          ease: "power1.inOut",
          paused: true,
          motionPath: {
            path: "#motionPath",
            align: "#motionPath",
            alignOrigin: [0.5, 0.5],
            autoRotate: true
          }
        });
    </script>
</body>
</html>